var documenterSearchIndex = {"docs":
[{"location":"#Dataflows.jl","page":"Home","title":"Dataflows.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a framework to run computations in a tolological order of the dependency graph. It aims to be fast and allocation free, for low-latency applications.","category":"page"},{"location":"#What-does-it-do?","page":"Home","title":"What does it do?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's give an example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Example of computational graph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, A, B, and C represent some inputs/sources to the graph. Meaning they contain some data. The nodes 1, 2 and 3 correspond to derived data sets:","category":"page"},{"location":"","page":"Home","title":"Home","text":"1 depends on A and B,\n2 depends on B,\n3 depends on 1, 2 and C.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This only mean that when A is updated, the nodes 1 and 3 must be updated, and in this order. When B is updated, nodes 1, 2 and 3 must be updated, either in (1, 2, 3) or (2, 1, 3) orders. Those 2 orders are called topological, for the DAG displayed above.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To build a graph, one needs to start with some inputs, which are roots of the graph. We can create inputs by providing any type, or by providing an object that will be mutated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"input_1 = input(Int64)\ninput_2 = input(Ref(0))","category":"page"},{"location":"","page":"Home","title":"Home","text":"!!! Note \"Inputs are never considered initialized\"     For now, when creating an input from an object, the initial value     will not be considered initialized before changing its value, or updating it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, derived nodes can be build with map","category":"page"},{"location":"","page":"Home","title":"Home","text":"node_1 = map(input_1) do x\n    println(\"node 1: $(2x)\")\n    2x \nend\nnode_2 = map(node_1, input_1, input_2) do x, y, z\n    println(\"node 2: $(x + y + z[])\")\n    x + y + z[]\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nTo ensure type stability, and performance, the types of the nodes are resolved at this stage. Hence the methods used in map must already be defined at this stage. We can verify that node_2 defined above contains a value of type Int.julia> eltype(node_2)\nInt64","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use this graph, we need to push values into the two inputs. We can either push a new value, or a function that mutates the current value. To do so, we need to wrap our inputs into a Source, and push to the sources, and not the inputs directly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"s1 = Source(input_1) # Captures the current state of the graph. Nodes must not be added afterwards.\ns2 = Source(input_2) # Captures the current state of the graph. Nodes must not be added afterwards.\ns1[] = 1 # prints \"node 1: 2\". The second node cannot be evaluated since the data is missing\ns2[] = (x -> x[] = 2)# prints \"node 2: 5\"\ns1[] = 3 # prints \"node 1: 6\" \"node 2: 11\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"Introducing this wrapping may seem a bit cumbersome to the user. But it is used to achieve high performance. When creating a source, the current state of the graph is being captured in the parameters of the Source type. This allows to dispatch the subsequent calls to push! on performant generated methods. This capture of the the graph implies that we first need to build the complete graph before wrapping the inputs into sources. Otherwise, the nodes added subsequently will be ignored.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As explained, in the introduction, each time an input is updated, the data will flow down the graph,  updating all children nodes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nWe can notice how updating the first input only updates node_2 once. This differs with simple reactive programming implementations, where the graph is generally traversed in a depth-first manner, with repetitions (typycally if the graph is not a tree). Here the graph is traversed in the topologic order of the construction.","category":"page"},{"location":"#Controlling-the-flow-of-the-graph","page":"Home","title":"Controlling the flow of the graph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a way to avoid direct filter and indirect select triggering of children.","category":"page"},{"location":"#Filtering","page":"Home","title":"Filtering","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider the following case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"input_1 = input(Float64)\nn = map(x->println(\"new update: $x\"), input_1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To avoid triggering node n when the value of input_1 is NaN, one can use filter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"input_1 = input(Float64)\nfiltered = filter(x->!isnan(x), input_1)\nn = map(x->println(\"new update: $x\"), filtered)\n\ns1 = Source(input_1) # compiles the graph. Nodes must not be added afterwards.\ns1[] = 1.0 # prints \"new update: 1.0\"\ns1[] = NaN # prints nothing ","category":"page"},{"location":"#Selecting","page":"Home","title":"Selecting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider now the following case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"input_1 = input(Float64)\ninput_2 = input(Float64)\nfiltered = filter(x->!isnan(x), input_1)\nn = map(filtered, input_2) do x, y\n    println(\"new update: $(x+y)\")\n    x + y\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Even if input_1 if filtered, when input_2 is triggered, the value of filtered will be used, whether the filtering condition is activated or not. To prevent the computation of n, users should use select instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"input_1 = input(Float64)\ninput_2 = input(Nothing)\nfiltered = select(x->!isnan(x), input_1)\nselected = select(x->!isnan(x), input_1)\nmap((x,y) -> println(\"filtered\"), filtered, input_2)\nmap((x,y) -> println(\"selected\"), selected, input_2)\n    \ns1 = Source(input_1) # compiles the graph. Nodes must not be added afterwards.\ns2 = Source(input_2) # compiles the graph. Nodes must not be added afterwards.\ns1[] = 1.0 # prints nothing \ns2[] = nothing # prints \"filtered\" and then \"selected\"\ns1[] = NaN # prints nothing \ns2[] = nothing # prints \"filtered\" only","category":"page"},{"location":"#Comparison-with-Observables.jl","page":"Home","title":"Comparison with Observables.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dataflows.jl executes nodes in a topological order of the graph, while Observables.jl uses a depth-first ordering (each node calling its children).","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Observables\njulia> x1 = Observable(nothing)\n       x2 = map(x->println(\"x2\"), x1)\n       x3 = map(x->println(\"x3\"), x1)\n       x4 = map(x->println(\"x4\"), x2, x3)\n       x1[] = nothing\nx2\nx4\nx3\nx4\njulia> using Dataflows\n       x1 = input(nothing)\n       x2 = map(x->println(\"x2\"), x1)\n       x3 = map(x->println(\"x3\"), x1)\n       x4 = map(x->println(\"x4\"), x2, x3)\n       Source(x1)[] = nothing\nx2\nx3\nx4","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, Dataflows.jl is designed for performance, in the case of static graphs, while Observables is designed for dynamic graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using BenchmarkTools\njulia> x1 = Observable(1)\n       x2 = map(x->x+1, x1)\n       @benchmark setindex!($x1, 2)\nBenchmarkTools.Trial: 10000 samples with 195 evaluations.\n Range (min … max):  484.185 ns …  6.983 μs  ┊ GC (min … max): 0.00% … 90.47%\n Time  (median):     490.810 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   496.060 ns ± 72.381 ns  ┊ GC (mean ± σ):  0.18% ±  1.22%\n\n     ▄██▆▃▁                                                     \n  ▁▃▆██████▇▅▄▄▄▃▃▃▄▃▃▃▃▃▂▃▃▂▂▂▂▂▂▂▂▂▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  484 ns          Histogram: frequency by time          534 ns <\n\n Memory estimate: 48 bytes, allocs estimate: 3.\n\njulia> x1 = input(Int)\n       x2 = map(x->x+1, x1)\n       s = Source(x1)\n       @benchmark setindex!($x1, 2)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  1.500 ns … 10.625 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     1.542 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.573 ns ±  0.221 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n           █         ▇        ▃         ▃         ▁          ▁\n  █▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▅ █\n  1.5 ns       Histogram: log(frequency) by time     1.75 ns <\n\n  Memory estimate: 0 bytes, allocs estimate: 0.\n","category":"page"},{"location":"#Benchmark","page":"Home","title":"Benchmark","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This library is meant to be fast, and allocation free. Here is an example using the main operations of DataFlows.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>i1 = input(Int)\n      i2 = input(Bool)\n      i3 = input(Bool)\n      i1f = filter(i1, i2)\n      i1s = select(i1, i3)\n      n2 = map(x->x+1, i1f)\n      n3 = foldl((state, x)-> state + x, 1, i1s)\n      n4 = inlinedmap(+,n2,n3)\n      n5 = lag(1, n4)\n      \n      s1 = Source(i1)\n      s2 = Source(i2)\n      s3 = Source(i3)\n      s1[] = 1\n      s2[] = true\n      s3[] = true\n      v = 1\n      @benchmark setindex!($s1, $v)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  5.240 ns … 128.238 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     5.400 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   5.774 ns ±   1.958 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▅█▇▂    ▁          ▁       ▁                                ▁\n  ████▄▄▄▇█▄▅▅▅▄▃▅▆▇▇█▇▆▆▄▅▅▅█▇▆▆▅▅▅▆▆▆▆▆▇▆▆▇▆▇▇▆▆▇█▇▆▆▆▆▆▆▆▆ █\n  5.24 ns      Histogram: log(frequency) by time      10.1 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nOrder = [:function, :type]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules=[DataFlows]","category":"page"},{"location":"#DataFlows.Node","page":"Home","title":"DataFlows.Node","text":"Node{name}\n\nObjects of type Node correspond to the nodes of the computational graph. Each node is identified by a uniquely generated name name.\n\n\n\n\n\n","category":"type"},{"location":"#DataFlows.Source-Tuple{DataFlows.Node}","page":"Home","title":"DataFlows.Source","text":"Source(::Node)\n\nTransforms an input node into a Source, which is a type stable version of the former. This type is used to update the roots of the graph with setindex!, similarly to a Ref. The input objects are not used directly, for performance considerations.\n\njulia> i = input(String)\n       m = map(println, i)\n       s = Source(i)\n       s[] = \"example\"\nexample\n\njulia> i = input(Ref(0))\n       m = map(println, i)\n       s = Source(i)\n       s[] = ref -> ref[] = 123\n123\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{DataFlows.Node, DataFlows.Node}","page":"Home","title":"Base.filter","text":"filter(x::Node, condition::Node; name)\n\nBulds a node that contains the same value as node x, but that does not update its children when the value of condition is true.\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Function, DataFlows.Node}","page":"Home","title":"Base.filter","text":"filter(f::function, x::Node; name)\n\nBulds a node that contains the same value as node x, but that only forwards an update when the function f is returns true, while evaluated on the value of node x. \n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\n\n\n\n\n","category":"method"},{"location":"#Base.foldl-Union{Tuple{TState}, Tuple{Function, TState, DataFlows.Node, Vararg{DataFlows.Node}}} where TState","page":"Home","title":"Base.foldl","text":"foldl(f, state, arg::Node, args::Node...; name)\n\nCreates a node that contains a state initialized by state. When any of the arguments are updated, the state is updated by calling state_updated = f(state, arg, args...).\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\n\n\n\n\n","category":"method"},{"location":"#Base.map-Tuple{Function, DataFlows.Node, Vararg{DataFlows.Node}}","page":"Home","title":"Base.map","text":"map(f, arg::Node, args::Node...; name)\n\nCreates a node whose value is given by calling f with the values of the nodes (arg, arg...).\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\n\n\n\n\n","category":"method"},{"location":"#DataFlows.constant-Tuple{Any}","page":"Home","title":"DataFlows.constant","text":"constant(x; name)\n\nBulds a node that contains the constant value x, and that does not propagate directly. If x is a Bool, then the constant value will be propagated by Julia's compiler.\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\n\n\n\n\n","category":"method"},{"location":"#DataFlows.inlinedmap-Tuple{Any, DataFlows.Node, Vararg{DataFlows.Node}}","page":"Home","title":"DataFlows.inlinedmap","text":"inlinedmap(f, arg::Node, args::Node...; name)\n\nSimilarly to map, creates a node whose value is given by calling f with the values of the nodes (arg, arg...). Contrarily to map, the value is not stored, and the function call is performed each time the value of the node is required.\n\nSee the implementation of lag for a use case example.\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\n\n\n\n\n","category":"method"},{"location":"#DataFlows.input-Tuple{T} where T","page":"Home","title":"DataFlows.input","text":"input(x; name)\n\nCreates a node that contains x. This should be used when x is mutable. To push a value in the node, one need to wrap it in a Source, and call setindex!.  See Source.\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\nExample:\n\njulia> i = input(Ref(0))\n       s = Source(i)\n       s[] = x -> x[] = 1\n\n\n\n\n\n","category":"method"},{"location":"#DataFlows.input-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"DataFlows.input","text":"input(::Type{T}; name)\n\nCreates a node that will contain a element of type T. To push a value in the node, one need to wrap it in a Source, and call setindex!. See Source.\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\nExample:\n\njulia> i = input(Int)\n       s = Source(i)\n       s[] = 1\n\n\n\n\n\n","category":"method"},{"location":"#DataFlows.lag-Tuple{Integer, DataFlows.Node}","page":"Home","title":"DataFlows.lag","text":"lag(n::Integer, node::Node; name)\n\nCreates a node that contains the n-th lagged value of node.\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\nExample:\n\njulia> i = input(Int)\n       n = lag(2, i)\n       map(print, n)\n       s = Source(i)\n       for x = 1:7\n           s[] = x\n       end\n12345\n\n\n\n\n\n","category":"method"},{"location":"#DataFlows.quiet-Tuple{DataFlows.Node}","page":"Home","title":"DataFlows.quiet","text":"quiet(node::Node; name)\n\nCreates a node that contains the same value as node, but does not trigger its children.\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\n\n\n\n\n","category":"method"},{"location":"#DataFlows.select-Tuple{DataFlows.Node, DataFlows.Node}","page":"Home","title":"DataFlows.select","text":"select(x::Node, condition::Node; name)\n\nBulds a node that contains the same value as node x, but that prevents updating its children when the value of condition is false.\n\nIf name is provided, it will be appended to the generated symbol that identifies the node.\n\n\n\n\n\n","category":"method"}]
}
