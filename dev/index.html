<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DataFlows.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>DataFlows.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#What-does-it-do?"><span>What does it do?</span></a></li><li><a class="tocitem" href="#Getting-Started"><span>Getting Started</span></a></li><li><a class="tocitem" href="#Controlling-the-flow-of-the-graph"><span>Controlling the flow of the graph</span></a></li><li><a class="tocitem" href="#Comparison-with-Observables.jl"><span>Comparison with Observables.jl</span></a></li><li><a class="tocitem" href="#Benchmark"><span>Benchmark</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/poncito/DataFlows.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dataflows.jl"><a class="docs-heading-anchor" href="#Dataflows.jl">Dataflows.jl</a><a id="Dataflows.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Dataflows.jl" title="Permalink"></a></h1><p>This package provides a framework to run computations in a tolological order of the dependency graph. It aims to be fast and allocation free, for low-latency applications.</p><h2 id="What-does-it-do?"><a class="docs-heading-anchor" href="#What-does-it-do?">What does it do?</a><a id="What-does-it-do?-1"></a><a class="docs-heading-anchor-permalink" href="#What-does-it-do?" title="Permalink"></a></h2><p>Let&#39;s give an example.</p><p><img src="assets/map.svg" alt="Example of computational graph"/></p><p>Here, <code>A</code>, <code>B</code>, and <code>C</code> represent some inputs/sources to the graph. Meaning they contain some data. The nodes <code>1</code>, <code>2</code> and <code>3</code> correspond to derived data sets:</p><ul><li><code>1</code> depends on <code>A</code> and <code>B</code>,</li><li><code>2</code> depends on <code>B</code>,</li><li><code>3</code> depends on <code>1</code>, <code>2</code> and <code>C</code>.</li></ul><p>This only mean that when <code>A</code> is updated, the nodes <code>1</code> and <code>3</code> must be updated, and in this order. When <code>B</code> is updated, nodes <code>1</code>, <code>2</code> and <code>3</code> must be updated, either in (<code>1</code>, <code>2</code>, <code>3</code>) or (<code>2</code>, <code>1</code>, <code>3</code>) orders. Those 2 orders are called <em>topological</em>, for the DAG displayed above.</p><h2 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h2><p>To build a graph, one needs to start with some inputs, which are roots of the graph. We can create inputs by providing any type, or by providing an object that will be mutated.</p><pre><code class="language-julia hljs">input_1 = input(Int64)
input_2 = input(Ref(0))</code></pre><p>!!! Note &quot;Inputs are never considered initialized&quot;     For now, when creating an input from an object, the initial value     will not be considered <em>initialized</em> before changing its value, or updating it.</p><p>Then, derived nodes can be build with <code>map</code></p><pre><code class="language-julia hljs">node_1 = map(input_1) do x
    println(&quot;node 1: $(2x)&quot;)
    2x 
end
node_2 = map(node_1, input_1, input_2) do x, y, z
    println(&quot;node 2: $(x + y + z[])&quot;)
    x + y + z[]
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To ensure type stability, and performance, the types of the nodes are resolved at this stage. Hence the methods used in map must already be defined at this stage. We can verify that <code>node_2</code> defined above contains a value of type <code>Int</code>.</p><pre><code class="language-julia hljs">julia&gt; eltype(node_2)
Int64</code></pre></div></div><p>To use this graph, we need to push values into the two inputs. We can either push a new value, or a function that mutates the current value. To do so, we need to wrap our inputs into a <code>Source</code>, and push to the sources, and not the inputs directly.</p><pre><code class="language-julia hljs">s1 = Source(input_1) # Captures the current state of the graph. Nodes must not be added afterwards.
s2 = Source(input_2) # Captures the current state of the graph. Nodes must not be added afterwards.
s1[] = 1 # prints &quot;node 1: 2&quot;. The second node cannot be evaluated since the data is missing
s2[] = (x -&gt; x[] = 2)# prints &quot;node 2: 5&quot;
s1[] = 3 # prints &quot;node 1: 6&quot; &quot;node 2: 11&quot;.</code></pre><p>Introducing this wrapping may seem a bit cumbersome to the user. But it is used to achieve high performance. When creating a source, the current state of the graph is being captured in the parameters of the <code>Source</code> type. This allows to dispatch the subsequent calls to <code>push!</code> on performant generated methods. This capture of the the graph implies that we first need to build the complete graph before wrapping the inputs into sources. Otherwise, the nodes added subsequently will be ignored.</p><p>As explained, in the introduction, each time an input is updated, the data will flow down the graph,  updating all children nodes.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We can notice how updating the first input only updates <code>node_2</code> once. This differs with simple <em>reactive programming</em> implementations, where the graph is generally traversed in a depth-first manner, with repetitions (typycally if the graph is not a tree). Here the graph is traversed in the topologic order of the construction.</p></div></div><h2 id="Controlling-the-flow-of-the-graph"><a class="docs-heading-anchor" href="#Controlling-the-flow-of-the-graph">Controlling the flow of the graph</a><a id="Controlling-the-flow-of-the-graph-1"></a><a class="docs-heading-anchor-permalink" href="#Controlling-the-flow-of-the-graph" title="Permalink"></a></h2><p>This package provides a way to avoid direct <a href="#Base.filter-Tuple{DataFlows.Node, DataFlows.Node}"><code>filter</code></a> and indirect <a href="#DataFlows.select-Tuple{DataFlows.Node, DataFlows.Node}"><code>select</code></a> triggering of children.</p><h3 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h3><p>Consider the following case:</p><pre><code class="language-julia hljs">input_1 = input(Float64)
n = map(x-&gt;println(&quot;new update: $x&quot;), input_1)</code></pre><p>To avoid triggering node <code>n</code> when the value of <code>input_1</code> is <code>NaN</code>, one can use <a href="#Base.filter-Tuple{DataFlows.Node, DataFlows.Node}"><code>filter</code></a>.</p><pre><code class="language-julia hljs">input_1 = input(Float64)
filtered = filter(x-&gt;!isnan(x), input_1)
n = map(x-&gt;println(&quot;new update: $x&quot;), filtered)

s1 = Source(input_1) # compiles the graph. Nodes must not be added afterwards.
s1[] = 1.0 # prints &quot;new update: 1.0&quot;
s1[] = NaN # prints nothing </code></pre><h3 id="Selecting"><a class="docs-heading-anchor" href="#Selecting">Selecting</a><a id="Selecting-1"></a><a class="docs-heading-anchor-permalink" href="#Selecting" title="Permalink"></a></h3><p>Consider now the following case:</p><pre><code class="language-julia hljs">input_1 = input(Float64)
input_2 = input(Float64)
filtered = filter(x-&gt;!isnan(x), input_1)
n = map(filtered, input_2) do x, y
    println(&quot;new update: $(x+y)&quot;)
    x + y
end</code></pre><p>Even if <code>input_1</code> if filtered, when <code>input_2</code> is triggered, the value of <code>filtered</code> will be used, whether the filtering condition is activated or not. To prevent the computation of <code>n</code>, users should use <a href="#DataFlows.select-Tuple{DataFlows.Node, DataFlows.Node}"><code>select</code></a> instead:</p><pre><code class="language-julia hljs">input_1 = input(Float64)
input_2 = input(Nothing)
filtered = select(x-&gt;!isnan(x), input_1)
selected = select(x-&gt;!isnan(x), input_1)
map((x,y) -&gt; println(&quot;filtered&quot;), filtered, input_2)
map((x,y) -&gt; println(&quot;selected&quot;), selected, input_2)
    
s1 = Source(input_1) # compiles the graph. Nodes must not be added afterwards.
s2 = Source(input_2) # compiles the graph. Nodes must not be added afterwards.
s1[] = 1.0 # prints nothing 
s2[] = nothing # prints &quot;filtered&quot; and then &quot;selected&quot;
s1[] = NaN # prints nothing 
s2[] = nothing # prints &quot;filtered&quot; only</code></pre><h2 id="Comparison-with-Observables.jl"><a class="docs-heading-anchor" href="#Comparison-with-Observables.jl">Comparison with Observables.jl</a><a id="Comparison-with-Observables.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-with-Observables.jl" title="Permalink"></a></h2><p>Observables provides a nice API </p><h2 id="Benchmark"><a class="docs-heading-anchor" href="#Benchmark">Benchmark</a><a id="Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark" title="Permalink"></a></h2><p>This library is meant to be fast, and allocation free. Here is an example using the main operations of DataFlows.jl.</p><pre><code class="language-julia hljs">julia&gt;i1 = input(Int)
      i2 = input(Bool)
      i3 = input(Bool)
      i1f = filter(i1, i2)
      i1s = select(i1, i3)
      n2 = map(x-&gt;x+1, i1f)
      n3 = foldl((state, x)-&gt; state + x, 1, i1s)
      n4 = inlinedmap(+,n2,n3)
      n5 = lag(1, n4)
      
      s1 = Source(i1)
      s2 = Source(i2)
      s3 = Source(i3)
      s1[] = 1
      s2[] = true
      s3[] = true
      v = 1
      @benchmark setindex!($s1, $v)
BenchmarkTools.Trial: 10000 samples with 1000 evaluations.
 Range (min … max):  5.240 ns … 128.238 ns  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     5.400 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   5.774 ns ±   1.958 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅█▇▂    ▁          ▁       ▁                                ▁
  ████▄▄▄▇█▄▅▅▅▄▃▅▆▇▇█▇▆▆▄▅▅▅█▇▆▆▅▅▅▆▆▆▆▆▇▆▆▇▆▇▇▆▆▇█▇▆▆▆▆▆▆▆▆ █
  5.24 ns      Histogram: log(frequency) by time      10.1 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><ul><li><a href="#Base.filter-Tuple{DataFlows.Node, DataFlows.Node}"><code>Base.filter</code></a></li><li><a href="#Base.filter-Tuple{Function, DataFlows.Node}"><code>Base.filter</code></a></li><li><a href="#Base.foldl-Union{Tuple{TState}, Tuple{Function, TState, DataFlows.Node, Vararg{DataFlows.Node}}} where TState"><code>Base.foldl</code></a></li><li><a href="#Base.map-Tuple{Function, DataFlows.Node, Vararg{DataFlows.Node}}"><code>Base.map</code></a></li><li><a href="#DataFlows.constant-Tuple{Any}"><code>DataFlows.constant</code></a></li><li><a href="#DataFlows.inlinedmap-Tuple{Any, DataFlows.Node, Vararg{DataFlows.Node}}"><code>DataFlows.inlinedmap</code></a></li><li><a href="#DataFlows.input-Tuple{T} where T"><code>DataFlows.input</code></a></li><li><a href="#DataFlows.input-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>DataFlows.input</code></a></li><li><a href="#DataFlows.lag-Tuple{Integer, DataFlows.Node}"><code>DataFlows.lag</code></a></li><li><a href="#DataFlows.quiet-Tuple{DataFlows.Node}"><code>DataFlows.quiet</code></a></li><li><a href="#DataFlows.select-Tuple{DataFlows.Node, DataFlows.Node}"><code>DataFlows.select</code></a></li><li><a href="#DataFlows.Node"><code>DataFlows.Node</code></a></li><li><a href="#DataFlows.Source-Tuple{DataFlows.Node}"><code>DataFlows.Source</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DataFlows.Node" href="#DataFlows.Node"><code>DataFlows.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Node{name}</code></pre><p>Objects of type <code>Node</code> correspond to the nodes of the computational graph. Each node is identified by a uniquely generated name <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/graph.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFlows.Source-Tuple{DataFlows.Node}" href="#DataFlows.Source-Tuple{DataFlows.Node}"><code>DataFlows.Source</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Source(::Node)</code></pre><p>Transforms an input node into a <code>Source</code>, which is a type stable version of the former. This type is used to update the roots of the graph with <code>setindex!</code>, similarly to a <code>Ref</code>. The input objects are not used directly, for performance considerations.</p><pre><code class="language-julia hljs">julia&gt; i = input(String)
       m = map(println, i)
       s = Source(i)
       s[] = &quot;example&quot;
example

julia&gt; i = input(Ref(0))
       m = map(println, i)
       s = Source(i)
       s[] = ref -&gt; ref[] = 123
123</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/compilation.jl#L7-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter-Tuple{DataFlows.Node, DataFlows.Node}" href="#Base.filter-Tuple{DataFlows.Node, DataFlows.Node}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter(x::Node, condition::Node; name)</code></pre><p>Bulds a node that contains the same value as node <code>x</code>, but that does not update its children when the value of <code>condition</code> is true.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/filter.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter-Tuple{Function, DataFlows.Node}" href="#Base.filter-Tuple{Function, DataFlows.Node}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter(f::function, x::Node; name)</code></pre><p>Bulds a node that contains the same value as node <code>x</code>, but that only forwards an update when the function <code>f</code> is returns <code>true</code>, while evaluated on the value of node <code>x</code>. </p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/filter.jl#L19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.foldl-Union{Tuple{TState}, Tuple{Function, TState, DataFlows.Node, Vararg{DataFlows.Node}}} where TState" href="#Base.foldl-Union{Tuple{TState}, Tuple{Function, TState, DataFlows.Node, Vararg{DataFlows.Node}}} where TState"><code>Base.foldl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">foldl(f, state, arg::Node, args::Node...; name)</code></pre><p>Creates a node that contains a state initialized by <code>state</code>. When any of the arguments are updated, the state is updated by calling <code>state_updated = f(state, arg, args...)</code>.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/foldl.jl#L19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map-Tuple{Function, DataFlows.Node, Vararg{DataFlows.Node}}" href="#Base.map-Tuple{Function, DataFlows.Node, Vararg{DataFlows.Node}}"><code>Base.map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map(f, arg::Node, args::Node...; name)</code></pre><p>Creates a node whose value is given by calling <code>f</code> with the values of the nodes <code>(arg, arg...)</code>.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/map.jl#L15-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFlows.constant-Tuple{Any}" href="#DataFlows.constant-Tuple{Any}"><code>DataFlows.constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constant(x; name)</code></pre><p>Bulds a node that contains the constant value x, and that does not propagate directly. If <code>x</code> is a <code>Bool</code>, then the constant value will be propagated by Julia&#39;s compiler.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/constant.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFlows.inlinedmap-Tuple{Any, DataFlows.Node, Vararg{DataFlows.Node}}" href="#DataFlows.inlinedmap-Tuple{Any, DataFlows.Node, Vararg{DataFlows.Node}}"><code>DataFlows.inlinedmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inlinedmap(f, arg::Node, args::Node...; name)</code></pre><p>Similarly to <code>map</code>, creates a node whose value is given by calling <code>f</code> with the values of the nodes <code>(arg, arg...)</code>. Contrarily to map, the value is not stored, and the function call is performed each time the value of the node is required.</p><p>See the implementation of <code>lag</code> for a use case example.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/inlinedmap.jl#L9-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFlows.input-Tuple{T} where T" href="#DataFlows.input-Tuple{T} where T"><code>DataFlows.input</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input(x; name)</code></pre><p>Creates a node that contains <code>x</code>. This should be used when <code>x</code> is mutable. To push a value in the node, one need to wrap it in a <code>Source</code>, and call <code>setindex!</code>.  See <a href="#DataFlows.Source-Tuple{DataFlows.Node}"><code>Source</code></a>.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; i = input(Ref(0))
       s = Source(i)
       s[] = x -&gt; x[] = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/input.jl#L45-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFlows.input-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#DataFlows.input-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>DataFlows.input</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input(::Type{T}; name)</code></pre><p>Creates a node that will contain a element of type <code>T</code>. To push a value in the node, one need to wrap it in a <code>Source</code>, and call <code>setindex!</code>. See <a href="#DataFlows.Source-Tuple{DataFlows.Node}"><code>Source</code></a>.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; i = input(Int)
       s = Source(i)
       s[] = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/input.jl#L22-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFlows.lag-Tuple{Integer, DataFlows.Node}" href="#DataFlows.lag-Tuple{Integer, DataFlows.Node}"><code>DataFlows.lag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lag(n::Integer, node::Node; name)</code></pre><p>Creates a node that contains the <code>n</code>-th lagged value of <code>node</code>.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; i = input(Int)
       n = lag(2, i)
       map(print, n)
       s = Source(i)
       for x = 1:7
           s[] = x
       end
12345</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/lag.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFlows.quiet-Tuple{DataFlows.Node}" href="#DataFlows.quiet-Tuple{DataFlows.Node}"><code>DataFlows.quiet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quiet(node::Node; name)</code></pre><p>Creates a node that contains the same value as <code>node</code>, but does not trigger its children.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/quiet.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFlows.select-Tuple{DataFlows.Node, DataFlows.Node}" href="#DataFlows.select-Tuple{DataFlows.Node, DataFlows.Node}"><code>DataFlows.select</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select(x::Node, condition::Node; name)</code></pre><p>Bulds a node that contains the same value as node <code>x</code>, but that prevents updating its children when the value of <code>condition</code> is <code>false</code>.</p><p>If <code>name</code> is provided, it will be appended to the generated symbol that identifies the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/poncito/DataFlows.jl/blob/fac9346d9bbe02788cc7ec3b82f553afaf2b65f1/src/selecter.jl#L3-L12">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 26 April 2023 09:52">Wednesday 26 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
